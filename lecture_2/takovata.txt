2. Основни структури от данни - str, list, tuple, set, dict; Character encoding
str
Едноредов стринг
string, или както се казва в Python - str, е последователност от символи. Дефинира се, подобно на други езици, като стойността се огражда в кавички, като Python не прави разлика между единични ' или двойни " кавички.

sentence1 = 'стойността се огражда в кавички'
sentence2 = "Python не прави разлика между единични или двойни кавички"
Ако на два отделни реда имате два стринга без нищо освен whitespace между тях, Python ще ги обедини в един. Това е удобен начин да пренесете дълги стрингове на няколко реда.

>>> sentence_long = 'стойността се огражда в кавички'
    'Python не прави разлика между единични или двойни кавички'
print(sentence_long)
'стойността се огражда в кавичкиPython не прави разлика между единични или двойни кавички'
Както виждате, при това положение Python няма да прибави интервал между двата стринга - ... кавичкиPython ....

Ако се налага да имате същата кавичка, с която сте дефинирали стринга, като символ в самия string, трябва да я "escape"-нете с наклонена черта.

sentence2 = "Python не прави разлика между единични ' или двойни \" кавички"
sentence2 = 'Python не прави разлика между единични \' или двойни " кавички'
Многоредов стринг
За да дефинирате многоредов стринг, използвайте записа с 3 кавички - без значение единични или двойни.

sentence3 = """
За да дефинирате
многоредов стринг,

използвайте записа с 3 кавички

- без значение единични или двойни.
"""
При този запис Python ще запази новите редове.

Често този запис се използва и за коментиране на код на няколко реда едновременно, тъй като в Python липсва синтаксис за многоредови коментари.

Методи на обекта str
По-долу са дадени най-често използваните методи на str обекта.

Пълно описнание можете да намерите в документацията на Python, както и в autocomplete в PyCharm.

Търсене
index(sub[, start[, end]]) и rindex() - връща индекса на първото срещане на под-стринга в стринга, но ако не бъде намерено съвпадение вдига exception
find(sub[, start[, end]]) и rfind() - връща индекса на първото срещане на под-стринга в стринга, но ако не бъде намерено съвпадение връща "-1"
startswith(prefix[, start[, end]]) - връща булев резултат (True/False), ако стрингът започва с подадения под-стринг
endswith(suffix[, start[, end]]) - връща булев резултат (True/False), ако стрингът свършва с подадения под-стринг
>>> sentence4 = 'най-често използваните методи на str обекта.'

>>> sentence4.find('често')
4

>>> sentence4.find('между')
-1

>>> sentence4.index('често')
4

>>> sentence4.index('между')
ValueError                                Traceback (most recent call last)
....
----> 1 sentence4.index('между')
ValueError: substring not found

>>> sentence4.startswith('най-')
True

>>> sentence4.startswith('често')
False

>>> sentence4.endswith('обекта.')  # с точка
True

>>> sentence4.endswith('обекта')  # без точка
False
Заместване, изчистване, разделяне и промяна
Можете да съедините съдържанието на два или повече str с оператор +.

Методите, които 'променят' стринга, всъщност връщат нов обект str!

replace(old, new[, count])
strip([chars]), lstrip([chars]) и rstrip([chars]) - изчиства всички срещания в начaлото и в края на стринга на някои от символите в параметъра chars; ако не се подаде chars, се изчистват 'whitespace' символите - интервал, таб, нови редове и други;
upper(), lower()
join(arg) - връща нов string при който всеки елемент от arg е комбиниран със самия string. Този метод ще разгледаме по-подробно малко по-късно.
>>> sentence5 = "Методите на str, които 'променят' стринга, всъщност връщат нов обект str"
>>> sentence5.replace('str', 'стринг')   # замества всички срещания
"Методите на стринг, които 'променят' стринга, всъщност връщат нов обект стринг"

>>> sentence6 = '  \t интервал, таб, нови редове  \n\n\t '

>>> sentence6.strip()
'интервал, таб, нови редове'

>>> sentence6.lstrip()
'интервал, таб, нови редове  \n\n\t '

>>> sentence6.rstrip()
'  \t интервал, таб, нови редове'

>>> sep = ' , '
>>> sep.join(["A" , "B" , "C"])
'A , B , C '
slicing и разделяне
s[idx] с положителна стойност на idx - връща idx-тия символ от началото на стринга (отпред назад); индексите започват от 0
s[-idx] с отрицателна стойност на idx - връща idx-тия символ от края на стринга (отзад напред); -1 - последния символ, -2 - предпоследния символ
s[from:]
s[from:to]
s[:to]
s[:to:step]
>>> sentence7 = "Let's look at what's happening here. Just as before, we're specifying that we want to start at position 4 (zero-based) in the string"
>>> sentence7[11]
'a'
>>> sentence7[-1]
'g'
>>> sentence7[-2]
'n'

>>> sentence7[11:]
"at what's happening here. Just as before, we're specifying that we want to start at position 4 (zero-based) in the string"
>>> sentence7[11:35]
"at what's happening here"
>>> sentence7[:35]
"Let's look at what's happening here"
>>> sentence7[11:55:2]
'a htshpeighr.Js sbfr,w'
split(sep=None, maxsplit=-1) - разделя стринга на указаните разделители, и връща списък с разделените подстрингове по подразбиране sep е whitespace (интервали, таб, нови редове и т.н.)
splitlines() - разделя стринга на линии
>>> sentence8 = 'Python enables programs to be written compactly and readably.'
>>> sentence8.split()
['Python', 'enables', 'programs', 'to', 'be', 'written', 'compactly', 'and', 'readably.']

>>> sentence8.split('o')
'Pyth', 'n enables pr', 'grams t', ' be written c', 'mpactly and readably.']

>>> sentence9 = 'Beautiful is better than ugly. \r\n Beautiful is better than ugly. \n   Readability counts. '
>>> sentence9.splitlines()
['Beautiful is better than ugly. ',
 ' Beautiful is better than ugly. ',
 '   Readability counts. ']
форматиране
Форматирането на стрингове е удобен начин за вмъкване на стойности в стрингов шаблон.

!!! ВНИМАНИЕ !!! Никога, ама НИКОГА не използвайте само стрингово форматиране с данни от външни източници, за да "сглобите" SQL заявки към бази данни, за да създадете HTML документи, да извиквате външни команди и т.н. Този тип грешки се наричат с общото наименование "Injection", и е най-често срещаната уязвимост в днешните софтуерни системи. Същото, разбира се, важи и за "сглобяване на стрингове с плюсчета".

След това стряскащо предупреждение, да видим малко прости примери:

"Today is {} °C outside".format(-8)
Можем да използваме и keyword argumens (за които ще говорим по-подробно в следващата лекция):

"Today is {temp} °C outside".format(temp=-8)
str.format() е доста мощен метод, но в голяма част от случаите простото форматиране, показано по-горе, върши работа. По-любопитните могат да погледнат Format String Syntax и Format Specification Mini-Language.

Старият начин за стрингово форматиране в Python използва операторът % и много прилича на printf() от C:

"Today is %s °C outside" % -8
Този начин на стрингово форматиране е доста често използван, особено в Python2, както и в по-стар код, но има някои недостатъци. Ако Ви е интересно, можете да погледнете printf-style String Formatting

Полезни линкове:

PyFormat Using % and .format() for great good!
isxxxx
Полезни за бърза проверка на съдържанието на стринга:

.isdigit()
.isalnum(), .isalpha()
.islower(), .isupper(),
>>> '56'.isdigit()
True
>>> 'Beautiful is better than ugly'.islower()
False
>>> 'readability counts'.islower()
True
По-подробно за encoding и Unicode
Какво означава "encoding"
"encoding" - правила за интерпретиране на последователност от байтове в определен контекст.
"Encoding" е общ термин, който не важи само за текстова, но и за много други видове информация - аудио, видео, структури от данни и т.н.

ASCII
В зората на компютрите, където най-вече развитието е в САЩ, първо възниква необходимостта от обработка на текстова информация. ASCII е прост encoding, който съпоставя числата от 0 до 127 (7 бита) към символи. Оригиналният ASCII включва

от 0 до 31 и 127 - контролни символи, основно използвани в ранните терминали, както и символите за нов ред (#13 или 0x0D) и line feed (#10 или 0x0A).
от 32 до 47, от 58 до 64, от 91 до 96 - пунктоационни символи - !, ?, $ , @, [, } и други;
от 48 до 57 - цифрите от 0 до 9
от 65 до 122 - буквите от английската азбука
В един момент изключително изненадващо се оказало, че на света не е само английската азбука, и се въвежда "Extended ASCII", който вече е 8-битов, и при който числата от 0 до 127 съвпадат с интерпретацията на оригиналния ASCII, а от 128 до 255 са поместени основно символи от западно-европейските езици - ü, ä, ê, ç, é и т.н., както и графични символи за рамки и запълване на местата на символите - ╤, ╟, ╔ и други.

Останалите хора по света - например България и Русия, където не се използват тези символи, предефинират Extended ASCII и създават множество свои encodings, при които символите от 128 до 255 представляват буквите от азбуката на кирилица.

Особено с развитието на Интернет в средата на 90-те години става ясно, че е невъможно нормална работа с интернационални документи, докато за представянето на символи се използва само 1 байт.

Какво е UCS & Unicode?
UCS и Unicode са ISO/IEC стандарт, описващ начина на електронно запазване на символи, знаци, цисла, идеограми, логограми. Това е основният стандарт който е приет от всички по света - включително Кирай и Северна Корея За разлика от ASCII където може да имаме само 256 "символа", Unicode може да съдържа 1,114,112 уникални символа. В момента Unicode съдържа "само" ~120,737 символа. Това включва всяка една известна писменост в човешката история, включително и всички китайски йероглифи (около 40000). Допълнително Unicode има огромен набор от научни символи (∫,∊), общоизвестни символи (卍,☭,☮,☪), емотиконки (☺,❤,☃) и какво ли още не - символ изобразяващ купчина фекалии.

При ASCII беше почти невъзможно в един документ да имаш текст на няколко езика, но в Unicode това не е никакъв проблем.

Най-важното нещо, което трябва да разберете за Unicode е, че всички съвременни компютърни системи използват тази кодова таблица. Използвайте я и Вие, за да сте съвместими с Живота, Вселената и всичко останало.

UTF-8
Unicode е универсален, но заема много място. Всеки символ се описва с приблизително 4 байта (32 бита), което го прави неефективен откъм запазване на информацията и прехвърлянето й по мрежа.

UTF-8 е енкодинг, при който символите от Unicode се представят (кодират) така, че символите от оригиналния ASCII (включващи английската азбука и основните символи и препинателни знаци) заемат 1 байт, а тези от най-често използваните езици заемат 2 байта, останалите заемат 3, 4 или повече байта.

Тъй като стойностите за символите от оригиналния ASCII съвпадат с тези в UTF-8 ( напр. стойност 65 представя символа А, стойност 122 представя символа z) , всеки файл, записан в оригиналния ASCII encoding е и валиден UTF-8.

Тъй като символите от масово използваните езици заемат само 1 или 2 байта, това позволява ефективно запазване и пренос на текстове.

Работата с UTF-8 е трудна (поради променливия брой байтове, необходими за представянето на различните символи), и за това много програми и езици вътрешно конвертират UTF-8 в Unicode и работят директно с Unicode. Предимството на този подход е, че прави изпълнението на програмата много по-ефективно, защото символите са с един и същ размер, но недостатъкът е, че програмата има нужда от повече RAM.

Най-важното нещо което трябва да разберете за UTF-8 е, че един символ може да заема с 1 байт, а друг символ може да заема 3 . Кирилицата заема 2 байта за всеки символ, така че думата Чушкопек ще има нужда от 16 байта в UTF-8.

UTF-16 и други често използвани encodings
Освен UTF-8, има и други енкодинги като UTF-7, UTF-16, UTF-32, но най-масовият е UTF-8. Той е много ефективен когато текста се състои основно от английски или западноевропейски символи, но ако по-голямата част от текста е съставен от йероглифи или други символи, UTF-16 е по-подходящ.

Също така UTF-16 е по-ефективен за представянето на символите в паметта.

UTF-7 трябва да бъде забранен с международна конвенция под заплаха от нападение с ядрено оръжие, ако някой го използва. Не го използайте никога, освен ако не Ви е опрян пистолет в главата.

Полезни линкове
Много полезно видео как работи UTF-8
Wikipedia - UTF-8
Wikipedia: Universal Coded Character Set (UCS)
А в Python?
Python 3 поддържа пълния набор от UCS с размер на символите до 4 байта, като интерпретаторът преценява как да представи string-а, в зависимост от представянето на символа с най-голям ред. Например, ако string-ът съдържа само ASCII символи (от латинската азбука, цифри и основните препинателни знаци), Python ще използва само по 1 байт за съхранение на стринга; ако string-ът съдържа и символи на кирилица - целият string ще използва по 2 байта за всеки символ, и т.н. Тази и други хитрости позволяват по-оптимално използване на паметта на компютъра.

а UTF-8?
За целта първо трябва да обясним за bytes :o)

bytes
bytes е структура от данни, представляваща последователност от байтове. Не символи, а байтове.

Използва се при вход/изход от външни източници на информация, както ще покажем в следващите лекции.

info_read_from_a_file = b'\xd0\x90! \xd0\x9a\xd0\xb8\xd1\x80\xd0\xb8\xd0\xbb\xd0\xb8\xd1\x86\xd0\xb0, \xd0\xba\xd0\xbe\xd0\xb4\xd0\xb8\xd1\x80\xd0\xb0\xd0\xbd\xd0\xb0 \xd0\xb2 UTF-8 :\xd0\xbe)'
Ако стойността на байт-а съвпада със стойност от ASCII номера на символ, който може да се изпечата на конзолата, Python ще го покаже като нормална латинска буква; в противен случай записът е \xHH , къдeto HH е шестнайсетично число от 00 до FF. Както виждате от примера по-горе, в bytes обекта се чете 'UTF-8', както и интервалите, удивителната, ':' и ')'.

и к'во го правим това?
'това' е обикновено информацията, която ще прочетете, ако отворите нормален текстов файл, кодиран в UTF-8. За да можете да направите нещо смислено с прочетеното, трябва да 'декодирате' информацията съгласно encoding, с който е била записана.

В Python 3 това става така:

print(info_read_from_a_file.decode('utf-8'))
И понеже 'UTF-8' е най-популярният character encoding, това прави абсолютно същото:

print(info_read_from_a_file.decode())
Методът decode() преобразува байтове към str (или текстова инфорамция);

а наопаки?
"опаки" в случая е кодирането (encoding) на текстовата информация във вид, в който ще може да бъде записана във файл, и след това прочетена от някой друг ( дано :о) ).

Изненадващо, в случая използваме методът encode() на str:

info_to_be_written_out = 'Да видим това дали ще можем да го прочетем после?'.encode('utf-8')
И, както и при decode(), ако не се подаде изрично име на encoding, се приема UTF-8:

info_to_be_written_out = 'Да видим това дали ще можем да го прочетем после?'.encode()
Примери на живо
Примерите на живо са писани по време на лекцията, така че доста често са разхвърляни, и в тях са показани много неща. Използвайте ги, за да си припомните обясненията по време на лекцията.

sentence3 = "За да дефинирате многоредов стринг"

print(sentence3.replace('а', 'AA'))
print(sentence3)

print(sentence3[3])

print(sentence3[3:15])
print(sentence3[3:])
print(sentence3[:])
print('---')
print(sentence3[9:156])

# new way of formatting strings
name = 'boris'
print("I am {name} and I'm happy {when}".format(name=name, when='now'))

price = 37.345523
print("Price: {:.2f}".format(price))

# old way for string formatting
print("I am %s and I'm happy " % name)

print(len("За - ! :)"))

print(sentence3[1])

print(len(sentence3))

parts = "I am %s and I'm happy".split()
print("-".join(parts))

print("12345678901234567890"[:10])

t = "12345678901234567890"
d = "67"

print(t[t.index(d) + len(d):])
В следващите лекции ще пострадаме по-сериозно от character encoding.

Задача: 1. Ограничете дължината на текст
Задача: 2. Вземете текста след определен подстринг
Задача: 3. Инициали
list
list е подредена структура, като елементите могат да бъдат от различни типове, и да се повтарят.

values = [1, 5.6, 'dve']
DEMO
Стандартни операции
... познати от почти всеки език за програмиране:

индексиран достъп до елементите - values[2] # == 'dve', като индексите започват от 0
присвояване на нова стойност на елемент по индекс - values[2] = 'друга стойност'
добавяне на елемент в края - values.append(784)
вмъкване на елемент - values.insert(0, 123), ще вмъкне стойността 123 на първо място в списъка
премахване на елемент - values.remove('dve') - премахва първото срещане на подадения елемент от списъка (не по индекс)
премахване на елемент по индекс - values.pop(2) - премахва елемента на подадения индекс, и връща стойността като резултат
можете да използвате и del values[2] , който обаче не връща премахнатата стойност
sort() - сортира елементите в list-а, като го променя
reverse() - обръща поредността на елементите в list-а
търсене на елемент - values.index(1)
изчистване - values.clear()
Допълнителни операции с list, налични в Python
преброяване на срещанията на елемент в list-а - values.count('dve')
проверка дали елемент се среща в списъка:
'dve' in values
'dve' not in values
събиране на списъци - values + [7, 11, 13, 17]
повтаряне на списък - [7, 11, 13, 17] * 2
slicing: при values = [1, 2, 3, 4, 5, 6, 7, 8]
values[1:] - връща нов списък с елементите от индекс 1 включително до края на списъка
values[2:5] - връща нов списък с елементите от индекс 2 (включително) до индекс 5 (изключващо)
values[:7] - връща нов списък с елементите до индекс 7 (изключващо)
values[::2] – връща нов списък с всеки втори елемент
values[-1] - връща последния елемент на списъка
values[-6: -2] - връща нов списък, като индексирането е отзад напред
values[-6: -2: 2] - всеки втори част от списъка, като индексирането е отзад напред
values[2:5] = [55,66,77,88,99,111] # замества елементите с индекси от 2 до 4 със списъка [55,66,77,88,99,111] ; резултатът е [1, 2, 55, 66, 77, 88, 99, 111, 6, 7, 8]
. . . :о)
Итериране на list
for value in values:
    print(value)
Ако ни е необходим и индекса на съответната стойност, можем да използваме enumerate()

for idx, value in enumerate(values):
    print(idx, ' - ', value)
Задача: 4. Средна цена, както се прави в белите държави
Примери на живо
Примерите на живо са писани по време на лекцията, така че доста често са разхвърляни, и в тях са показани много неща. Използвайте ги, за да си припомните обясненията по време на лекцията.

values = [1, 5.6, 'dve']

print(values)
print(values[2])
# print(values[23])  # will raise an error

print(values.index(1))

if 1 in values:
    print("ima go")
else:
    print("niama go")

values[2] = 'new string value'
values[1] = 'new string value'
print(values)

values.append(34)
print(values)

values.insert(0, 'something else')
print(values)

values.remove('new string value')
values.remove('new string value')
print(values)

removed_value = values.pop()
print(removed_value)

print(values)

numbers = list(range(20))
print(numbers)

print(numbers[2:34])
print(numbers[2:])
print(numbers[:5])
print(numbers[2:15:2])
print(numbers[-1])
print(numbers[len(numbers)-1])
print(numbers[-10::-2])

numbers = list(range(20))
print(numbers)

numbers[4] = 55
print(numbers)

print(numbers[4:6])
numbers[4:6] = [66, 77, 88]
numbers[4:6] = []
print(numbers)

numbers[3] = [98, 99, 100]
print(numbers)

matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9],
]

print(matrix[1][-1])
print(matrix)

numbers1 = list(range(10))
numbers2 = list(range(10, 20))
print(numbers1 + numbers2)
print(len(numbers1))
print(len(numbers2))
numbers1.append(numbers2)
print(numbers1)
print(len(numbers1))
print(len(numbers1 + numbers2))
numbers1 = numbers1 + numbers2   # numbers1.extend(numbers2)
print(numbers1)

# for current_index, element in enumerate(numbers1):
#     print(current_index, ' -> ', element)

numbers2.sort(reverse=True)
print(numbers2)
tuple
tuple може да съдържа стойности от различен тип (също както list), но веднъж създаден, не може да бъде променян (immutable). Това е и причината tuple да изисква много по-малко ресурси от list.

values = (2, 3, 'a')
DEMO
tuple поддържа само методите, които не променят съдържанието - count() и index(). Също така tuple поддържа и slicing, както е показахме преди малко за list.

Python позволява т.нар. expansion на стойности от тип tuple:

a, b = (2, 3)
а Python 3 поддържа и wildcard tuple expansion:

a, b, *rest = (4, 5, 6, 7, 8)
# a == 4
# b == 5
# rest == [6, 7, 8]
Итериране на tuple
for value in (1, 2, 4, 8, 16):
    print(value)
Ако ни е необходим и индекса на съответната стойност, можем да използваме enumerate()

for idx, value in enumerate((1, 2, 4, 8, 16)):
    print(idx, ' - ', value)
Примери на живо
Примерите на живо са писани по време на лекцията, така че доста често са разхвърляни, и в тях са показани много неща. Използвайте ги, за да си припомните обясненията по време на лекцията.

tuple_values = (1, 2.3, 'string value')
print(tuple_values)
print(tuple_values[1:])
# tuple_values[1] = 456

# expansion

number1, number2 = [1, 2]
print(number1)
print(number2)

numbers = list(range(10, 20))

for element in numbers:
    print(element)

for current_index, element in enumerate(numbers):
    print(current_index, ' -> ', element)

# --------------

current_index = 0
for element in numbers:
    print(current_index, ' -> ', element)
    current_index += 1

# --------------

print(numbers)
# using "neshto" to test what does "enumerate" return on every iteration
for neshto in enumerate(numbers):
    index = neshto[0]
    value = neshto[1]
    # is equivalent to:
    index, value = neshto  # expansion

    print(neshto)
set
Множеството (set) е съвкупност от уникални елементи. При него няма дефинирана подредба, а основната операция е принадлежност на елемент към множеството.

x = {1, 2, 3}
y = {3, 4, 5}
z = set(9, 10)
DEMO
Проверка за принадлежност:

>>> 5 in x
False
>>> 5 not in x
True
>>> 5 in y
True
Основни операции с множества


В Python е за предпочитане да използвате методите, тъй като са по-ясно четими за не-математици.

Итериране на set
for value in x:
    print(value)
Ако ни е необходим и индекса на съответната стойност, можем да използваме enumerate()

for idx, value in enumerate(x):
    print(idx, ' - ', value)
!! ВАЖНО !! Имайте предвид, че за set нямаме гарантирана последователност, т.е. итерацията на елементите може да се случи в произволен ред.

Задача: 5. Общи интереси
Примери на живо
Примерите на живо са писани по време на лекцията, така че доста често са разхвърляни, и в тях са показани много неща. Използвайте ги, за да си припомните обясненията по време на лекцията.

numbers1 = {1, 2, 3, 'chetiri', 5}
numbers2 = set((3, 4, 5, 6, 7))

print(numbers1)
print(numbers2)

print(2 in numbers1)

if 2 in numbers2:
    print('ima go')
else:
    print('niama go')

numbers1.add(77)
print(numbers1)
numbers1.add(2)
print(numbers1)

text = "Множеството (set) е съвкупност от уникални елементи. При него няма дефинирана подредба, а основната операция е принадлежност на елемент към множеството."

unique_chars = set()
for char in text:
    unique_chars.add(char)

print(unique_chars)
print(len(unique_chars))

unique_chars = set(text)
print(len(unique_chars))

# --------------------------------------

numbers1 = {1, 2, 3, 4, 5}
numbers2 = set((3, 4, 5, 6, 7))

print(numbers1 & numbers2)
print(numbers1.intersection(numbers2))

print(numbers1 | numbers2)
print(numbers1.union(numbers2))

print(numbers1 - numbers2)
print(numbers1.difference(numbers2))
dict
dict() (речник) представлява вградена структура от данни, която ни позволява да правим асоциация между ключ и стойност. В други езици е познат като Hashtable, асоциативен масив, hybrid dictionary, hash и т.н.

Например, искаме да запишем каква е температурата в различни градове, така че в последствие да можем да работим лесно с тази информация. В този случай името на града ще е ключа, а температурата ще е стойността на dict:

София: -14
В един речник може да имаме множество ключове/стойности:

Новосибирск: -31
Таити: 30
Най-лесният начин да създадем нов речник в Python е:

weather= {
    'София': -14,
    'Новосибирск': -31,
    'Таити': 30
}
Ако искаме да вземем температурата за определен град, използваме ключа (името на града):

temp = weather['София']
Ако искаме да променим стойност, отново използваме ключа:

weather['София'] = -2
Накратко, ако искаме да правим нещо с дадена стойност, трябва да се обърнем към нея използвайки ключа.

Какво ще стане, ако се опитаме да присвоим стойност на несъществуващ ключ:

weather['Ахваз'] = 46
Ако ключът вече съществува в dict-а, новата стойност ще се асоциира към този ключ, a ако не съществува ще се създаде нов елемент с този ключ.

Има няколко особености, с които трябва да се съобразявате, когато работите с речици:

Ключът трябва да бъде hashable елемент. Ако не разбирате какво точно означава hashable, не се притеснявайте - текст, цели числа, булеви стойност, tuples, sets са hashable. Никога не си позволявайте са използвате числа с плаваща запетая за ключове - може да имате доста неочаквани реултати, и почти невъзможни за откриване грешки;
Стойностите може да са всеки един възможен тип, който Python поддържа;
Не може да има два или повече еднакви ключа в един dict - идеята на ключът е да бъде уникален в целия речник;
Може да имате повтарящи се стойности (записани под различни ключове, разбира се);
Търсенето по ключ е изключително бърза операция - най-често със сложност O(1). Ако не знаете какво е O(1), приемете, че Python може да работи ефективно с речници от порядъка на стотици хиляди ключове;
Не може директно да търсите по стойности в речниците - необходим е ключ, за да вземете която и да е стойност;
Речниците нямат подредба -Python не гарантира, че елементите ще се итерират в същия ред, в който сте ги въвели. Ако имате нужда от подреден речник, Python предлага такава структура, която се нарича OrderedDict;
Ето някой от най-често използваните методи за работа с речници

my_dict = dict()  # създава нов празен речник

my_dict = {}  # идентично с горното. Това е приетият начин в света на Python да се създават нови речници

len(my_dict)  # връща броя на елементите (ключовете) в речника

del my_dict['key']  # премахва ключа и неговата стойност от речника

'my_key' in my_dict  # връща True ако 'my_key' съществува в речника, независимо от стойността, False ако го няма

'my_key' not in my_dict  # връща False ако 'my_key' съществува в речника, независимо от стойността, True ако го няма

my_dict.clear(my_dict)  # премахва всички ключове и стойности от речника

my_dict.get('my_key')  # връща стойността за 'my_key'. Ако 'my_key' не съществува се връща None

my_dict.get('my_key', 'default_value')  # връща стойността за 'my_key'. Ако 'my_key' не съществува се връща стойността подадена като втори параметър, в случая текста 'default_value'

my_dict.keys()  # връща 'списък' с всички ключове в речника. Стойностите не се връщата

my_dict.values()  # връща 'списък' с всички стойности в речника, ключовете не се връщат
Речниците могат да бъдат итерирани:

weather = {
    'София': -14,
    'Новосибирск': -31,
    'Таити': 30
}

for key in weather:
    print(key)  # при всяка итерация променливата key ще бъде един от ключовете в речника
    print(weather[key])  # тъй като имаме ключа може да вземем и стойността асоциирана с него

for key, value in weather.items():
    print(key)
    print(value)

for value in weather.items():
    print(value)
Интересен факт: Всеки JSON документ е валиден Python код, който дефинира dict или list или комбинирана структура от тях :о)

Задача: 6. Matchmaking
Задача: 7. Matchmaking - v2
Примери на живо
Примерите на живо са писани по време на лекцията, така че доста често са разхвърляни, и в тях са показани много неща. Използвайте ги, за да си припомните обясненията по време на лекцията.

temperatures = {
    'София': -14,
    'Новосибирск': -31,
    'Таити': 30,
    'Таити1': [30, 2],
    'Варна': {22, 3},
    'Русе': {
        "temperature": -23,
        "humidity": 90,
    },
    'ловдив': None,
    'Пазарджик': None
}

print("-" * 20)
print(temperatures)
print(temperatures['София'])
print(temperatures.get('Бургас'))
print(temperatures.get('Бургас', 'No data'))
print(temperatures.get('София', 'No data'))

# temp_burgas = temperatures.setdefault('Бургас', -2)

print("-" * 20)

key = 'Бургас'
if key in temperatures:
    print(temperatures[key])
else:
    print("No data for {}".format(key))

temperatures['Пловдив'] = 31
print(temperatures)

print("-" * 20)

for city_name in temperatures:
    temperature_data = temperatures[city_name]
    print(city_name, ' -> ', temperature_data)

for neshto in temperatures.items():
    key, value = neshto
    print(neshto)
    print(key)
    print(value)

for city_name, temperature_data in temperatures.items():
    print(city_name, ' -> ', temperature_data)

for temperature_data in temperatures.values():
    print(temperature_data)
Задачи
 	№	Име на задачата

1
Ограничете дължината на текст

2
Вземете текста след определен подстринг

3
Инициали

4
Средна цена, както се прави в белите държави

5
Общи интереси

6
Matchmaking

7
Matchmaking - v2